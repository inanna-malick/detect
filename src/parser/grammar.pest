WHITESPACE = _{ " " | "\t" | NEWLINE }

program = { SOI ~ expr ~ EOI }
expr = { prefix* ~ primary ~ (infix ~ prefix* ~ primary )* }
  infix = _{ and | or }
    and = { "&&" | ^"and" }
    or = { "||" | ^"or" }
  prefix = _{ neg }
    neg = { "!" | "\\!" | ^"not" }
  primary = _{ predicate | glob_pattern | "(" ~ expr ~ ")" }

predicate = { selector ~ operator ~ value }
  selector = @{ (ASCII_ALPHANUMERIC | "." | "_")+ }
  // Parse operators flexibly - validate in typechecker
  // Start with symbols or letters, but not mix arbitrarily
  operator = @{ 
    // Symbol-based operators (can combine symbols)
    ("=" | "!" | ">" | "<" | "~")+ |
    // Word-based operators (alphanumeric with underscores)
    (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
  }
  
  value = { quoted_string | raw_token }

  // Raw tokens - capture everything, decide meaning in typechecker based on operator context
  raw_token = { bracketed | parenthesized | curly_braced | bare_token }

  // Bracketed/parenthesized/braced content with optional quantifiers and repeated groups
  // Matches: [rs, js, ts], [0-9]+, [0-9]{2,4}, [a-z]+[A-Z]+, [0-9]+\.[0-9]+
  // Supports +, *, ?, {n,m} quantifiers and repeated bracket/paren groups
  bracketed = @{
    "[" ~ (!"]" ~ ANY)* ~ "]" ~
    ("+" | "*" | "?" | ("{" ~ ASCII_DIGIT+ ~ ("," ~ ASCII_DIGIT*)? ~ "}"))? ~
    (
      (!("[" | "(" | "{" | "]") ~ !WHITESPACE ~ !"&&" ~ !"||" ~ !")" ~ ANY)* ~
      "[" ~ (!"]" ~ ANY)* ~ "]" ~
      ("+" | "*" | "?" | ("{" ~ ASCII_DIGIT+ ~ ("," ~ ASCII_DIGIT*)? ~ "}"))?
    )* ~
    (!("[" | "(" | "{" | "]") ~ !WHITESPACE ~ !"&&" ~ !"||" ~ !")" ~ ANY)*
  }
  parenthesized = @{
    "(" ~ (!")" ~ ANY)* ~ ")" ~
    ("+" | "*" | "?" | ("{" ~ ASCII_DIGIT+ ~ ("," ~ ASCII_DIGIT*)? ~ "}"))? ~
    (
      (!("[" | "(" | "{" | ")") ~ !WHITESPACE ~ !"&&" ~ !"||" ~ ANY)* ~
      "(" ~ (!")" ~ ANY)* ~ ")" ~
      ("+" | "*" | "?" | ("{" ~ ASCII_DIGIT+ ~ ("," ~ ASCII_DIGIT*)? ~ "}"))?
    )* ~
    (!("[" | "(" | "{" | ")") ~ !WHITESPACE ~ !"&&" ~ !"||" ~ ANY)*
  }
  curly_braced = @{ "{" ~ (!"}" ~ ANY)* ~ "}" ~ (!WHITESPACE ~ !"&&" ~ !"||" ~ !")" ~ ANY)* }

  // Barewords exclude structural chars but allow most content
  bare_token = @{ (!("\"" | "'" | WHITESPACE | ")" | "&&" | "||") ~ ANY)+ }
  
  quoted_string = ${ "\"" ~ inner_double ~ "\"" | "'" ~ inner_single ~ "'" }
  inner_double = @{ (!"\"" ~ (escaped | ANY))* }
  inner_single = @{ (!"'" ~ (escaped | ANY))* }
  
  escaped = { "\\" ~ ("\"" | "'" | "\\" | "n" | "t" | "r") }

glob_pattern = @{ (ASCII_ALPHANUMERIC | "*" | "/" | "." | "_" | "-" | "?" | "[" | "]")+ }

// Separate entry point for parsing set contents
// Used by typechecker when operator is 'in'
set_contents = { SOI ~ set_items? ~ EOI }
set_items = { set_item? ~ ("," ~ set_item?)* }
set_item = { quoted_string | bare_set_item }
// Bare items in sets: stop at comma, whitespace, or quotes
bare_set_item = @{ (!("," | "\"" | "'" | WHITESPACE) ~ ANY)+ }