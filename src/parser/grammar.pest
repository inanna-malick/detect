WHITESPACE = _{ " " | "\t" | NEWLINE }

program = { SOI ~ expr ~ EOI }
expr = { prefix* ~ primary ~ (infix ~ prefix* ~ primary )* }
  infix = _{ and | or }
    and = { "&&" | ^"and" }
    or = { "||" | ^"or" }
  prefix = _{ neg }
    neg = { "!" | "\\!" | ^"not" }
  primary = _{ predicate | glob_pattern | "(" ~ expr ~ ")" }

predicate = { selector ~ operator ~ value }
  selector = @{ (ASCII_ALPHANUMERIC | "." | "_")+ }
  // Parse operators flexibly - validate in typechecker
  // Start with symbols or letters, but not mix arbitrarily
  operator = @{ 
    // Symbol-based operators (can combine symbols)
    ("=" | "!" | ">" | "<" | "~")+ |
    // Word-based operators (alphanumeric with underscores)
    (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
  }
  
  value = { quoted_string | raw_token }

  // Raw tokens - capture everything, decide meaning in typechecker based on operator context
  raw_token = { bracketed | parenthesized | curly_braced | bare_token }

  // Capture complete bracketed/parenthesized/braced content
  bracketed = @{ "[" ~ (!"]" ~ ANY)* ~ "]" }
  parenthesized = @{ "(" ~ (!")" ~ ANY)* ~ ")" }
  curly_braced = @{ "{" ~ (!"}" ~ ANY)* ~ "}" }

  // Barewords exclude structural chars but allow most content
  // Note: { and } allowed to support regex quantifiers like \d{1,3}
  bare_token = @{ (!("[" | "(" | "\"" | "'" | WHITESPACE | ")" | "&&" | "||") ~ ANY)+ }
  
  quoted_string = { "\"" ~ inner_double ~ "\"" | "'" ~ inner_single ~ "'" }
  inner_double = @{ (!"\"" ~ (escaped | ANY))* }
  inner_single = @{ (!"'" ~ (escaped | ANY))* }
  
  escaped = { "\\" ~ ("\"" | "'" | "\\" | "n" | "t" | "r") }

glob_pattern = @{ (ASCII_ALPHANUMERIC | "*" | "/" | "." | "_" | "-" | "?" | "[" | "]")+ }