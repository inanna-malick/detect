WHITESPACE   =  _{ " " | "\t" | NEWLINE }


bare_char = { ASCII_ALPHANUMERIC | "." | "_" | "/" | "-" | "+" | "@" | "#" | "$" | "%" | "^" | "&" | "*" | "~" | "\\" | "[" | "]" | "{" | "}" | "|" | "?" | "," }
size_unit = { kb | mb | gb | tb }
  kb = { ^"kb" | ^"k" }
  mb = { ^"mb" | ^"m" }
  gb = { ^"gb" | ^"g" }
  tb = { ^"tb" | ^"t" }
set_char = { ASCII_ALPHANUMERIC | "." | "_" | "/" | "-" | "+" | "@" | "#" | "$" | "%" | "^" | "&" | "*" | "~" | "\\"  | "{" | "}" | "(" | ")" | "|" | "?" }
inner_char = @{ !("\"" | "'") ~ ANY }

escaped = { "\\" ~ escapable }
escapable = { "n" | "\\" | "\""}

program         =   { SOI ~ expr ~ EOI }
  expr          =   { prefix* ~ primary ~ (infix ~ prefix* ~ primary )* }
    infix       =  _{ and | or }
      and       =   { "&&" | ^"and" } // logical and (symbol or case-insensitive word)
      or        =   { "||" | ^"or" }  // logical or (symbol or case-insensitive word)
    prefix      =  _{ neg }
      neg       =   { "!" | ^"not" }  // Negation (symbol or case-insensitive word)
    primary     =  _{ typed_predicate | "(" ~ expr ~ ")" }


// Typed predicates - each combines selector, operator, and appropriate RHS
typed_predicate = { string_predicate | numeric_predicate | temporal_predicate }

// String predicates (for name, path, content, and type selectors)
string_predicate = {
    string_selector ~ string_op_value
}
  string_op_value = _{
    string_regex |
    string_eq |
    string_ne |
    string_contains |
    string_in
  }
  string_selector = { path_selector | bare_path_shorthand | content_selector | type_selector }
    // Hierarchical path selectors
    path_selector = { path_with_component | path_alias }
    path_alias = { "path" } // Alias for path.full
    
    // Bare shorthand forms for path selectors (without path. prefix)
    bare_path_shorthand = { 
        bare_name | bare_stem | bare_extension | bare_parent | bare_full
    }
    bare_name = { "name" | "filename" }
    bare_stem = { "stem" }
    bare_extension = { "extension" | "ext" }
    bare_parent = { "parent" }
    bare_full = { "full" }
    path_with_component = {
        "path" ~ "." ~ (path_full | path_parent_dir | path_parent | path_name | path_stem | path_extension)
    }
    path_full = { "full" }
    path_parent = { "parent" }
    path_parent_dir = { "parent_dir" }
    path_name = { "name" }
    path_stem = { "stem" }
    path_extension = { "extension" | "ext" }
    
    // Content selectors with domain support
    content_selector = { content_with_domain | bare_content }
    content_with_domain = { "content" ~ "." ~ "text" }
    bare_content = { "text" | "contents" | "content" }  // text is new shorthand, keep others for compat
    
    // Type selector with meta domain support
    type_selector = { meta_type | bare_type }
    meta_type = { "meta" ~ "." ~ "type" }
    bare_type = { type }
    type = { "filetype" | "type" }

  string_eq = { eq ~ string_value }
  string_ne = { ne ~ string_value }
  string_contains = { contains ~ string_value }
  string_regex = { (match_ | like) ~ string_value }
  string_in = { in_ ~ set_literal }

  string_value = { quoted_string | bare_string }
  bare_string = @{ bare_char+ }

// Numeric predicates (for size and depth selectors)
numeric_predicate = {
    numeric_selector ~ numeric_op_value
}
  numeric_selector = { meta_size | meta_depth | bare_size | bare_depth }
    meta_size = { "meta" ~ "." ~ "size" }
    meta_depth = { "meta" ~ "." ~ "depth" }
    bare_size = { size }
    bare_depth = { depth }
  numeric_op_value = _{
    numeric_eq |
    numeric_ne |
    numeric_comparison
  }
  size = { "filesize" | "size" }
  depth = { "depth" }
  
  numeric_eq = { eq ~ numeric_value }
  numeric_ne = { ne ~ numeric_value }
  numeric_comparison = { (gteq | lteq | gt | lt) ~ numeric_value }
  
  numeric_value = { size_value | bare_number }
  size_value = ${ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? ~ size_unit }
  bare_number = @{ ASCII_DIGIT+ }

// Temporal predicates (for time selectors)
temporal_predicate = {
    temporal_selector ~ temporal_op_value
}
  temporal_op_value = _{
    temporal_eq |
    temporal_ne |
    temporal_comparison
  }
  temporal_selector = { time_with_domain | bare_time }
    time_with_domain = { "time" ~ "." ~ (modified | created | accessed) }
    bare_time = { modified | created | accessed }
    modified = { "modified" | "mtime" }
    created  = { "created" | "ctime" }
    accessed = { "accessed" | "atime" }
    
  temporal_eq = { eq ~ temporal_value }
  temporal_ne = { ne ~ temporal_value }
  temporal_comparison = { (gteq | lteq | gt | lt) ~ temporal_value }
  
  temporal_value = { absolute_date | relaxed_time_value | time_value | quoted_string | time_keyword }
  absolute_date = ${ ASCII_DIGIT{4} ~ "-" ~ ASCII_DIGIT{2} ~ "-" ~ ASCII_DIGIT{2} }  // YYYY-MM-DD format
  relaxed_time_value = ${ "-"? ~ ASCII_DIGIT+ ~ time_unit }  // Optional minus, no period required
  time_value = ${ "-" ~ ASCII_DIGIT+ ~ "." ~ time_unit }     // Legacy format for compatibility
  time_keyword = { "now" | "today" | "yesterday" }
  time_unit = { seconds | minutes | hours | days | weeks | months }
    seconds = { "seconds" | "second" | "secs" | "sec" | "s" }
    minutes = { "minutes" | "minute" | "mins" | "min" | "m" }
    hours   = { "hours" | "hour" | "hrs" | "hr" | "h" }
    days    = { "days" | "day" | "d" }
    weeks   = { "weeks" | "week" | "w" }
    months  = { "months" | "month" }

// Shared operator definitions
eq       = { "==" | "=" }         // exact equals
ne       = { "!=" }               // not equal
like     = { "~=" | "~" }         // regex (backward compat)
match_   = { "=~" }               // regex (explicit)
gteq     = { ">=" }
lteq     = { "<=" }
gt       = { ">" }
lt       = { "<" }
in_      = { "in" }               // set membership
contains = { "contains" }         // substring match

// Shared value definitions
set_literal = { "[" ~ set_items? ~ "]" }
  set_items = { set_item ~ ("," ~ set_item)* }
  set_item = { set_token | quoted_string }
  set_token = @{ set_char+ }

quoted_string = ${ double_quoted | single_quoted }
  double_quoted = { "\"" ~ inner_double ~ "\"" }
  single_quoted = { "'" ~ inner_single ~ "'" }
  inner_double = @{ (!"\"" ~ ANY)* }
  inner_single = @{ (!"'" ~ ANY)* }
